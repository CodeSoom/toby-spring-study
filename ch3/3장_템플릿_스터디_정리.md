# 3장 템플릿
## (토비 님)
여러 종류의 템플릿으로 끝나는 기술들이 있고 여러분들이 접하실 가능성도 꽤 있고, 간단한 것만 쓰면 감춰져서 안보이는 부분에서 동작하는 경우도 많이 있다. 
하지만 이제 여기에 적용된 원리들로 스프링이 추구하는 객체지향적인 설계 기법들을 이해할 수 있다. 이는 아주 오래된 전통적인 그런 것들을 응용한 것이다. (토비 님: 저는 사실 이거 보면서 되게 놀랍거든요)
왜냐하면 3장에서 제시하는 문제들을 해결하는 다양한 당시의 유명한 개발자들이 소개하는 기법들이 있었어요. 
try-catch-final 이라는 반복되는 코드를 작성하고 깜빡해서 close 하는 것을 하나 잊은 상황에서 서버를 일주일 정도 돌린다면 ? 
갑자기 어느날 리소스 풀이라고 나와서 서버가 꺼져버리는 현상을 목격할거고 밤을 세우고 심지어는 소스 코드를 전부 출력을 해서 형광펜으로 하나식 줄을 그어 가면서 `무엇을 빼먹었는가` 에 대해 체크하는 경우도 생긴다. 진짜 그런 일들이 많았다.
그 시절에 스펙(?)을 만든 사람은 `이는 간단한 객체지향적인 디자인 패턴 몇 개만 응용하면 해결되지 않는가` 라는 해답을 내놓았다. (토비 님: 사람들이 이 생각을 왜 못 했을까 ? 자바를 많이 하고 잘한다는 사람들이) 
그중에는 안드로이드의 자바 라이브러리를 총지휘한 유명한 사람도 있는데, 그 사람도 그 사람이 만든 솔루션도 ~ 했거든요. (0사에 대한 이야기) 그 분이 00 에서 컨설턴트로 일하실 때 진짜 그런 상황을 많이 만났다.
(JDBC 로 개발을 진행한 상황) try-catch-final 의 어딘가에서 close 를 안하고 넘어가는게 있는데 A4 용지 한 페이지에 페이지가 네 장이 들어가는 형태로 수백장의 소스 코드를 출력한 다음에 형광펜 하나 잡고 try-catch-final 이 보이는 곳에다가 하나씩 밑줄 그어 가면서 close 빼먹은 곳이 있나 finally 빼먹은 데 있나 4-5 시간 정도를 진행. `이거 고치세요` 이러면 이 사람들한테 XX 원의 컨설팅 비용을 지불하였다. 
2000년대 초반에 유명한 자바 커뮤니티 그 분이 올리신 글을 보고 깜짝 놀랐던 적이 있다. close 를 누락하는 등의 오류는 어찌보면 간단한 코드지만 실수할 수 있는 내용이고 쉽게 찾아내기도 힘들 수 있겠구나라는 것을 절실하게 느꼈다.
(예제 이야기) 그래서 3장에 나오는 내용을 스프링을 통해서 배우게 되어 되게 좋았다. 이렇게 접근해 나가는 동안 객체지향적인 어떤 원리들이 `어떤 문제를 해결하기 위해서 쓰였는가` 이를 쭉 풀어나가는 방식으로 3장을 구성을 했다. 
2008 ~ 2010 년 초반에 이 책이 쓰인 당시에는 자바 6 까지 밖에 안나와서 자바 6 의 언어가 지원하는 내용만 사용을 했다. 
그 이후의 자바 7, 8, ... , 19 까지 나왔는데, 버전이 점점 올라가면서 이 책에서 작성했던 샘플 코드를 좀 더 개선할 수 있는 여러 가지 좋은 방법들이 나왔다. 
어쩌면 여기서 얘기하는 템플릿 콜백에 대한 완전히 새로운 방식의 접근 방법을 사용할 수 있게 되었다. 하지만 그럼에도 불구하고 최신 스프링에도 여전히 템플릿이 존재한다. 그게 어떤 의미가 있는 건지 이런 것들을 한번 쭉 얘기를 해보면 좋을 것 같다.  

## (느낀점) 
DB 접근에 대해 처음 배울 때 접하는 내용이 connection, preparedStatement, 그 다음에 JDBC 템플릿으로 넘어가게 된다. 그 패턴에 익숙해지니 SQL 문을 인터페이스로 분리하는 과정이 `오버엔지니어링이 아닌가 ?` 라 생각되었다. `SQL 문을 구현체로 추출하면 보기만 어렵지 않나 ?` 라는 생각도 했는데, 점점 JDBC 템플릿과 유사한 형태로 리팩토링이 진행됐다.

## (토비 님)
3장은 JDBC 템플릿 그 자체가 목적이 아니고, 이런 류의 문제를 만나게 되면 자바에서는 `어떤 디자인 방법적인 설계로 해결을 할 수 있는가 ?` 를 생각하게 하는게 목적이다. 
해당 챕터에서 나오는 DB 프로그램 작성에 대해 `이런 식으로 접근을 했어야 하나 ?` 라고 생각하는 것 보다는, 이런 코드로 작성을 해야 하던 시절에서 그 `문제를 해결하면서 어떤 접근 방법을 썼는가 ?` 에 대해 더 관심을 가져주는게 좋을 것 같다.


## (느낀점)
이너 클래스가 인상 깊었다. 잘못 사용하면 스파게티 코드가 되기 쉬운 부분이 있다. 직접 사용하기 보다는 `fake` 라는 이름의 로컬 클래스를 만들어서 쓰는 경우가 많다.

## (토비 님)
요즘 언어 차원에서 콜백, 람다를 지원하는 언어들이 워낙 많아서 그냥 그렇게 시작하면 된다고 생각할 수 있는데, 사실 그게 전통적인 객체지향 언어에서 발전해 파생되는 결과물이라 생각한다. 
그래서 이런 방향으로 접근 방법을 보는 것이 좋겠다는 생각이 든다. 


## (느낀점)
처음에는 테스트만 통과할 수 있는 적당히 구현된 코드가 나온다. 그리고 `변하는 것` 과 `변하지 않는 것` 을 분리하며 템플릿 콜백 패턴을 구현하는 과정이 나온다.  
그리고 어떤 설계에 대한 결정을 할 때, `왜 이런 선택을 하는지`, `뭐가 좋은지` 에 대한 이유를 설명한다. 예를 들면, `로컬 클래스를 선언하면 좋은 이유`, 그리고 `인터페이스를 거치지 않고 DI 를 하면 좋은 이유` 와 같은 내용인데 이런 이야기를 읽으면서 이유를 알게 된 것 같아서 되게 좋았다.
우리는 프레임워크에 사용자이면서 동시에 애플리케이션을 만든다. 우리가 애플리케이션을 만들 때도 우리가 사용하는 프레임워크처럼 변경에 유연하고 또 합체하기 쉬운 그런 것을 만들어야 한다. 이 프레임워크에 녹여져 있는 원리들을 배우고 또 적용하면 좋겠다.

## (토비 님)
제가 이 책에서 강조하고 싶었던 것은 스프링이 어느 날 갑자기 `JDBC 개발은 템플릿으로 해` 라며 만들어지지 않았다는 것이다. 스프링을 만든 개발자가 평범한 자바 접근 방법을 사용하여 만들어진 코드를 보고 문제 의식을 느꼈고, 여기에 객체지향적인 원리를 적용하니 이런 형식의 코드가 만들어졌고, 간결해지니 프레임워크화가 되었다. 
`우리가 만든 애플리케이션 코드에도 동일한 원리를 적용할 수 있지 않을까 ?` 사실 이런 내용을 이야기하고 싶었다. 그래서 스프링을 사용하면 `람다를 쓰는 코드` 를 많이 만들게 되는데, `람다를 받는 코드` 를 과연 만들어본 적이 있는지 이런 것을 한 번 생각해 볼 필요가 있을 것 같다. 
남이 만든 라이브러리에 람다식을 넣는 건 쉽게 할 수 있는데, 내가 만든 코드에 내가 만든 또 다른 코드 내지는 다른 사람이 내가 만든 코드를 사용할 때 `람다식을 넣을 수 있도록 만들어 낼 수 있는가 ?` 이 부분에 대한 고민이 필요하다고 생각한다. 예를 들어, 제너레이트, 에노테이션. 
템플릿 부분도 사실 이런 원리들을 적용한 코드를 가지고 고민을 풀어나가는 과정으로 나타내 굉장히 작은 스탭으로 서서히 진행시켰다. 
무슨 뭐하러 로컬 클래스를 만들고 그냥 한방에 가지 이렇게 말씀하시는 분들도 있는데, 근데 저는 이 문제를 풀어나가는 과정의 모든 부분이 답을 준다는 생각을 했고, 해결할 수 있는 솔루션들을 찾아보고, 그 장단점을 비교해보고, 최종적으로 선택지를 결정해서 그 방향으로 한방에 전진하는 식의 문제 접근 과정을 보여주고 싶었다. 


## (느낀점)
3장 읽으면서 `전략 패턴이랑 콜백 패턴 이래서 사용하게 되었구나` 를 가장 초창기에 쓰였던 코드부터 시작해서 순차적으로 보여주셔서 그 점이 정말 좋았습니다. 

## (토비 님)
`전략 패턴` 을 구성하는 것은 두 가지이다. `Context` 가 있고, Context 가 사용하는 `Strategy Interface` 가 있으면 된다.
`전략` 은 다른 말로 하면 `알고리즘` 이라 할 수 있다. 예를 들어, 어떤 코드가 돌아가는 문맥이 있을 때 문맥 중에서 어떤 특정한 알고리즘을 쓰는 부분이 있다고 하자.
이것을 Context 클래스 안에다가 내장을 시키지 않고 그냥 외부에서 통째로 다 받아서 해당 클래스를 가져다 쓰고 싶은 경우에 해당한다. 
이것을 쉽게 표현하자면 `전략 패턴은 알고리즘을 통째로 바꿔치기 할 수 있게 만든 패턴` 이라고 할 수 있다. 
그런데 자바에 나오는 라이브러리 중에 전략 패턴을 쓰는 것에 목적이 있는 것은 예를 들어, `sort` 에다 `Comparable Interface` 를 구현한 `Sorting` 을 할건데 어떤게 앞에 놓일지 어떤게 뒤에 놓일지에 대한 것을 결정하는게 하나의 알고리즘이라고 할 수 있다. 
즉, 값을 두 개 주면서 순서가 어떻게 될건지만 정해주면 나머지 Sorting 알고리즘은 Sorting 이라는 `Context` 에서 알아서 처리를 하는데 `비교를 한다` 라는 비교 알고리즘 자체를 외부에서 주입을 받는 것에 있다. 이런게 전략 패턴이다. 
전략 패턴은 전략 오브젝트를 `Context` 에다가 밀어 넣어주는 것 말한다. 그런데 이를 메소드의 파라미터로 넣기도 하고 아예 생성자에서 바로 그냥 내장시켜 버리기도 하는데 이것을 `콜백 템플릿` 또는 `템플릿 콜백 패턴` 이라고 붙여서 얘기를 한다. 

## `템플릿 콜백 패턴` 과 `전략 패턴` 의 차이점은 ?
디자인 패턴 얘기를 하면은 항상 이거부터 시작을 한다. 이게 `그` 디자인 패턴이다. 
`그` 라는 건 뭐냐면 `GoF` 라고 하는 네 명의 사람이 쓴 `객체지향 디자인 패턴` 이라는 책을 말한다. 이는 처음으로 이제 객체지향 디자인 패턴이라는 컨셉을 가지고 설명한 책이다.
`그` 객체지향 디자인 패턴 책에 나오는 패턴이 아닌 그외의 패턴들도 많이 있다. 그러나 `전략 패턴` 은 바로 `그` 객체지향 디자인 패턴 책에 나오는 패턴이다.

`템플릿 콜백 패턴` 은 `그` 책에 나오지 않는 한참 지나서 2000년대 초반에 스프링 책을 쓴 `로드 존슨` 이 디자인 테크닉의 일종으로 이름을 붙인 테크닉에 해당한다. 
(토비 님: 그 사람이 만든건지 다른 사람들이 했던 말을 가져다 쓴건지 그건 제가 기억을 못하겠다) 
스프링의 기원이 되는 코드들이 등장하는 책인데, 이 책에서는 `템플릿 콜백 패턴은 전략 패턴의 특별한 한가지 케이스다` 라고 설명을 하고 있다. 
그러니까 템플릿 콜백 패턴은 전략 패턴이에요. 근데 어떤 전략 패턴이냐면 전략 패턴은 그 전략이라는 것은 오브젝트니까 그 안에 수많은 메서드를 가지고 있을 수 있잖아요. 
전략을 바꿔치기 해야 되니까 추상 클래스를 가지거나 인터페이스를 구현을 해야 된다는 이야기이다. 그래야 그것을 상속하거나 다른 구현체로 바꿔치기할 수 있기 때문이다.

템플릿은 전략 패턴의 `Context` 고, 콜백은 전략 패턴의 `전략` 에 대한 것이다. 사실은 이 이야기는 함수형 프로그래밍의 `Higher-order function` 또는 `고계함수` 라고도 불리는 것에서 유래됐다. 
아무튼 많이들 아시니까. 많이들 들어보셨을텐데. ~해서 얘기하는 그 함수를 전달하는거 함수를 전달하는 파라미터로 전달하는 거 그거랑 사실상 기능적으로 똑같아요. 왜냐면 메서드가 딱 하나뿐이잖아요. 
인터페이스의 메서드가 하나면 그 전략이 구현하는 메소드도 당연히 하나 뿐이다. 하나 뿐인 전략을 허용하는 것을 우리는 특별히 `템플릿 콜백` 이라고 부른다. 이게 의외로 사용 용도가 되게 많다. 사용이 많아지면서 굳이 이름을 붙인 거다. 

또 얼마 전에도 어떤 분이 `템플릿 콜백 패턴이라는게 뭐냐 ? 전략 패턴이랑 무슨 상관이지 ? 같은 건가 다른 건가 ?` 이런 질문을 하셨는데, `전략 패턴의 스페셜한 케이스` 다. 
전략 인터페이스에 메서드가 하나 뿐인 것이다. 그러면 `요즘으로 치면 람다랑 비슷하네 ? 람다 리플렉션이랑 비슷하네 ?` 또는 `뭐 자바스크립트 콜백이나 클로져 함수 고계함수 이런 거랑 비슷하네 ?` 그렇다, 비슷하다. 
하지만 실제 사용되어진 상황을 보면 기존에 클래스로 많이 만들던 오브젝트이기 때문에 가진 조금 더 다른 특징이 있기는 하다. 그 부분을 구분하여 기억하면 좋을 것 같다.


## (느낀점)
`람다식은 객체인가?` 라는 질문에 람다식도 어쨌든 함수형 인터페이스를 구현한 구현체라고 생각을 하기 때문에 객체가 맞다는 생각을 했다. 
객체가 `상태` 또는 `행위` 를 가지고 있고, 식별자를 통해서 `식별` 할 수 있는 것이라 생각을 하고 있기 때문이다.

함수형 프로그래밍이라는 것을 자바에서 활용하기 위해서 오브젝트를 가져다 쓰는 상황이 되었는데, `자바에서 함수형 프로그래밍을 도입하기 위해 객체의 개념을 가져다 썼다` 정도로 이해하면 되는가 ?

## (토비 님)
네, 맞습니다. 그런데 람다가 나오기 전에 자바에서 주제가 `함수형 프로그래밍을 하자` 인 `Functional Programing For Java` 라는 책이 나왔었다. 
그래서 주로 익명 클래스가 람다랑 되게 비슷하다. 람다식이라는 것은 결국은 익명 함수이다. 함수긴 함수인데 이름이 없다. 
람다식에는 그냥 파라미터와 바디만 있으면 되는데, 이곳에 이름을 붙이지는 않는다. 또한, `익명 클래스` 도 `로컬 클래스` 에 이름을 생략한 형태이다.

람다식이 익명 클래스보다 상당히 많이 발전된 형태이기는 하다. (인터페이스가 구현되지 않은 람다식을 가져다 대입해도 호출되는 형태 등)
하지만 이런 점들을 제외하고 나면 익명 클래스와 동작이 거의 비슷하다. 딱 하나 다른건 this 에 대한 정의가 좀 다른데 람다식은 잘 쓰지 않는다.
(~~) 한 단계 더 나아간 형태가 람다식이라고 생각하면 되는데, 이게 스트림이 같이 등장을 했기 때문에 람다식이 의미가 있다.
스트림 안에서 내부의 상태를 계속 바꾸어가는, 즉 함수를 계속 evaluate 하다가 최종적으로 함수가 리턴하는 값을 가지고 복잡한 연산을 처리하게 하는 스타일로 코드를 작성하도록 유도하며 설계한 것이 람다식이기 때문에 이런 스타일로 사용하는 것에서 람다식은 의미가 있다.

**그러나 그냥 무조건 람다식으로 만들어야 된다는 것은 아니다.**
콜백 안에 복잡하고 고도화된 기능을 넣어놓고 콜백을 생성할 때 다른 의존 오브젝트를 주입하기도 하고 하지만 외부에 노출하는 퍼블릭 인터페이스는 단 하나 뿐인 경우에는 이것을 콜백으로 쓰겠어 하고 만들 수도 있다. (?)
이런 것은 람다식으로 대체가 불가능하죠. 왜냐하면 생성하는 시점에서 뭔가 고도화된 작업을 해야 되고 그다음에 여기다가 의미있는 이름을 붙여주는 것이 가독성을 위해서 중요하니까 람다식과 익명 클래스 혹은 일반 클래스의 ~ 콜백은 서로 대치해서 사용할 수 있어 어떤게 더 좋으냐 라는 절대적인 기준은 없는 거다. 
`람다로 써도 문제가 없겠네 ?` 네, 그냥 쓰셔도 됩니다. 그런데 람다를 하나를 코드 중간에다가 식만 달랑 가져다만 놓으면 도대체 뭐하는 식인지가 이해되지 않는다. 
그러면 타입을 가진 변수를 정의해서 그곳에 람다식을 작성하면 된다. 예제를 보면 `로우 매퍼` 라는 것이 나오는데 이런 것도 람다식으로 교체가 된다. 
람다식이랑 익명 클래스(일반 클래스) 랑 거의 일대일로 교체 가능하다. 결국 익명 클래스가 어떻게 만들어지고 사용되는가에 대해서 판단해야 한다. 언제든지 람다로 바꿀 수 있는데 어떤 경우에 바꾸는지도 판단해야 한다. 어떤 때는 익명 클래스 쓰고, 
어떤 때는 로컬 클래스 쓰고, 어떤 때는 그냥 일반 클래스 쓰고, 어떤 때는 중첩 클래스를 쓴다. 이것을 판단할 수 있는 구분 방법을 마련하라.

[When to Use Nested Classes, Local Classes, Anonymous Classes, and Lambda Expressions](https://docs.oracle.com/javase/tutorial/java/javaOO/whentouse.html)

잘 모르겠다면 오라클 문서를 보시면 된다. 오라클이 제공하는 `java tutorial` 은 자바 언어를 꼼꼼하게 알고 싶다면 읽는게 좋다고 생각한다. 
그리고 필수는 아니지만 관례적으로 `Functional Interface` 에 에노테이션을 붙인다. `@FunctionalInterface` 을 붙이면 람다라 생각하면 된다.
스프링의 JDBC 템플릿 중에서 콜백 인터페이스를 스프링 5.0 에서 찾아보면 `@FunctionalInterface` 가 붙어있다. 그렇다는 이야기는 옛날 방식의 익명 클래스를 써도 되지만, 람다식으로 써도 좋다라는 뜻이다. 
물론 좋다라고도 할 것도 없는게 `람다식으로 쓰는게 더 좋으니 써라` 라고 스프링이 적극적으로 권장을 하는거라고 생각하면 된다. 
그래서 요즘에는 템플릿 콜백이라는 말을 안쓰게 되었다. 
람다식을 받는 메서드는 `FunctionalInterface` 같은 메서드 하나짜리를 구현을 해야 하는데, 조금 더 정확하게 말하자면 인터페이스를 여러 개 구현해도 된다.
인터페이스를 3개 구현한 오브젝트가 있는데 이 3개의 인터페이스에 있는 메소드의 총 합계가 한 개면 얘는 람다식으로 쓰일 수 있다. 이 이야기는

```
marker interface ← 마킹 인터페이스
Serializable
```

구현한 인터페이스에 메서드가 없기 때문이다. 즉, 이 인터페이스는 내용이 없다. 만약에 어떠한 인터페이스를 만드는데 인터페이스가 임의의 메서드 하나를 갖고 있고 `Serializable` 같은 것을 상속했다면 
마킹 역할을 하기 위해서 인터페이스를 여러 개를 구현하고 있어도 얘를 갖다가 람다식으로 쓸 수 있는,, 어쨌든 전체 메서드의 합계가 하나면 된다. (토비 님: 이것을 가지고 재밌는 것을 할 수가 있어요. 이거에 대해서는 기회가 되면 보여드릴게요) 
**요즘에는 이 마킹 역할을 에노테이션으로 많이 쓰는데, 인터페이스를 쓰는 게 훨씬 좋다.** 이것도 이펙티브 자바에서 되게 강조하는 내용 중 하나이다.
인터페이스는 타입이기 때문에 타입 체킹이 가능하다. 타입으로 받을 수도 있다. 하지만 에노테이션은 리플렉션을 쓰지 않으면 붙어있는 건지 아닌지 감별할 수 없게 코드가 지저분하게 된다.


## (느낀점)
3장의 내용은 하나의 템플릿 같은 느낌이었다. 
문제를 해결해 나아가는데 있어서 객체지향적으로 생각했을 때 `변경이 되는 부분` 과 `안되는 부분` 을 명백하게 구분하는 것이 좋았다.
DI 할 때 인터페이스를 꼭 사용해야 한다는 생각을 가지고 있었는데 이번에 책을 읽으면서 꼭 인터페이스를 할 필요는 없구나, 
인터페이스가 아니어도 되는 경우가 있구나 이런 부분은 좀 저의 생각을 깨는 부분이 있었다.

## (토비 님)
OCP 는 절대 적용하자면 거의 모든 객체지향 디자인 원리를 가지고 ~. 
중복이 전체적으로 일어나면 굉장히 간단하다. 그 부분만 extract 해서 재사용하면 된다. 
그러나 중복이 부분만 일어난다면 `변하는 부분` 과 `분리시켜서 변하지 않는 부분` 을 구분하여 코드를 재사용하는 방향으로 가면 된다.
`변하는 부분` 을 `변하지 않는 부분` 에서 바라볼 때, 즉 템플릿에서 콜백을 바라볼 때, 어떻게 변하는지 템플릿이 모르게 만들면 된다. 이것이 객체지향적 설계나 프로그래밍의 핵심이다. 
절차지향적인 방식, 즉 데이터 중심의 코드에서는 전역변수를 사용한다. 이는 데이터를 중앙에 두고 모든 코드들이 그 데이터를 다 읽는 구조이다.
한 곳에서만 고치면 괜찮은데 여기서도 고치고 저기서도 고치고 하다보니 글로벌하게 노출이 된다.
그런 과정에서 이런 생각을 하게 된다. `아 이게 그 고치는 코드 이외에 자주 변경이 일어나게 되는데 얘를 어떻게 하면은 감출 수가 있을까 ?` 
그래서 나온 것이 캡슐화이다. 캡슐화를 데이터와 행위를 같이 모아놓는다는 의미로 많이들 설명하는데, 캡슐화에서 제일 중요한 것은 변하는 부분을 외부로부터 감추는 것이다. (~~) 
`데이터를 내가 Array 로 만들어 놨는데, 나중에 보니깐 Collection 으로 바뀌었네 ?`
이런 상황이 오면 객체지향적이지 않고 캡슐화도 잘 안됐다고 보는 것이다.
내부의 어떤 코드에 변경이 일어날 때 그 변경이 외부에서 감춰지게 잘 만들어야 캡슐화가 잘되었고 객체지향적인 코드라고 표현한다. 이걸 다르게 이야기하면 OCP 라고 할 수 있다. 
이는 기본적으로 코드를 개선할 때에 봐야하는 제일 중요한 내용 중 하나이다. **중복을 제거하고 변경된 부분과 변경되지 않는 부분을 잘 구분해야 한다.** 

Alan Kay(객체지향 프로그래밍 단어 창시자) 가 객체지향 프로그래밍이라는 것을 설명한 글이 있는데 이 사람이 강조하는 것은 이거다. **객체는 객체지향은 데이터를 없애는 거다.**
객체지향이란 것은 객체가 다른 객체한테 메세지를 보내서 그 메세지를 받는 객체가 메세지에 응답을 할 수 있게 어떤 명령과 같이 어떤 일을 수행하는 것이다.
이런 의미에서 람다도 메세지를 받아서 그 메세지를 해석하고 기능을 수행하는 코드라고 보기 때문에 객체라고 설명할 수 있다. 


## 템플릿 메서드 패턴과 템플릿 콜백 패턴의 차이
없다고 보는 게 맞는데, 유사성이 있기는 하다. 템플릿 쪽은 변하지 않는 것을 가리킨다. (이제 정리하기 힘들다 추후에 추가한다)


깃허브에 코드를 공유해 놨다. (봐야징)
